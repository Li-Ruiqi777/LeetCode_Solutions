# LeetCode_Solutions
算法刷题记录

> 25-6-2：hot100数组板块mid题

- 53.最大子数组和：维护一个`current_sum`和`max_sum`，当`current_sum<0`时丢弃之前的子数组重新开始
- 56.合并区间：先对所有区间排序；再判断result的最后一个元素和当前区间有没有交叉：没的话直接添加当前区间到result中，有的话就更新result的最后一个元素
- 189.轮转数组：3次反转数组法：先反转所有、再反转0~k，再反转k+1~n
- 238.除自身之外数组的乘积：结果等于前缀积 * 后缀积
  - 前缀积`left[i]` = `num[0]*num[1]*num[2]...*num[i-1]`(i>=1)
  - 后缀积`right[i]` = `num[i+1]*num[i+2]*num[i+3]...*num[n-1]`(i<=n-2)

> 25-6-3：hot100矩阵板块

- 73.矩阵置零：先遍历一次矩阵用`set`记录出现0所在的row和col，再遍历一次矩阵，将set中存的位置的所有元素置0

- 54.螺旋矩阵：

  - 设定边界：维护四个边界变量（上、下、左、右）来定义当前需要遍历的矩阵范围
  - 循环处理：按照"右→下→左→上"的顺序遍历每一层
  - 注意事项：遍历每层的时候左、右2侧都是闭区间，并且遍历完一层要立即更新边界，不然会出现最后一个元素遍历不到的情况；“左”和“上”的时候要再判断一下边界关系

- 48.旋转图像：

  - 非原地操作写法：`matrix_new[i][j] = matrix[cols-j-1][i]`
  - 原地操作写法：转置 + 水平翻转（都会用到`swap()`，别忘记了）

  ```
  原始矩阵：  转置后：      水平翻转后：
  1 2 3      1 4 7		7 4 1
  4 5 6  ->  2 5 8  -> 	8 5 2
  7 8 9	   3 6 9		9 6 3
  ```

- 240.搜索二维矩阵 II：
  - nt方法：遍历所有元素查找
  - 稍微好一点：逐行二分法
  - 最好的方法：从右上角或者左下角开始搜索，以从右上角开始为例：这是当前行的最大值，当前列的最小值
    - 如果 `target == matrix[i][j]`，找到目标
    - 如果 `target < matrix[i][j]`，排除当前列（因为当前列的所有元素都更大），向左移动
    - 如果 `target > matrix[i][j]`，排除当前行（因为当前行的所有元素都更小），向下移动
  - 该方法主要可以同时利用行、列的有序性，如果从左上角/右下角起始，就没法判断到底该在行还是列方向上移动了
