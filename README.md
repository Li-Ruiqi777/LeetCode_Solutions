# LeetCode_Solutions
算法刷题记录

## 数组

> 25-6-2：hot100数组板块mid题

- 53.最大子数组和：维护一个`current_sum`和`max_sum`，当`current_sum<0`时丢弃之前的子数组重新开始
- 56.合并区间：先对所有区间排序；再判断result的最后一个元素和当前区间有没有交叉：没的话直接添加当前区间到result中，有的话就更新result的最后一个元素
- 189.轮转数组：3次反转数组法：先反转所有、再反转0~k，再反转k+1~n
- 238.除自身之外数组的乘积：结果等于前缀积 * 后缀积
  - 前缀积`left[i]` = `num[0]*num[1]*num[2]...*num[i-1]`(i>=1)
  - 后缀积`right[i]` = `num[i+1]*num[i+2]*num[i+3]...*num[n-1]`(i<=n-2)



## 矩阵

> 25-6-3：hot100矩阵板块

- 73.矩阵置零：先遍历一次矩阵用`set`记录出现0所在的row和col，再遍历一次矩阵，将set中存的位置的所有元素置0

- 54.螺旋矩阵：

  - 设定边界：维护四个边界变量（上、下、左、右）来定义当前需要遍历的矩阵范围
  - 循环处理：按照"右→下→左→上"的顺序遍历每一层
  - 注意事项：遍历每层的时候左、右2侧都是闭区间，并且遍历完一层要立即更新边界，不然会出现最后一个元素遍历不到的情况；“左”和“上”的时候要再判断一下边界关系

- 48.旋转图像：

  - 非原地操作写法：`matrix_new[i][j] = matrix[cols-j-1][i]`
  - 原地操作写法：转置 + 水平翻转（都会用到`swap()`，别忘记了）

  ```
  原始矩阵：  转置后：      水平翻转后：
  1 2 3      1 4 7		7 4 1
  4 5 6  ->  2 5 8  -> 	8 5 2
  7 8 9	   3 6 9		9 6 3
  ```

- 240.搜索二维矩阵 II：
  - nt方法：遍历所有元素查找
  - 稍微好一点：逐行二分法
  - 最好的方法：从右上角或者左下角开始搜索，以从右上角开始为例：这是当前行的最大值，当前列的最小值
    - 如果 `target == matrix[i][j]`，找到目标
    - 如果 `target < matrix[i][j]`，排除当前列（因为当前列的所有元素都更大），向左移动
    - 如果 `target > matrix[i][j]`，排除当前行（因为当前行的所有元素都更小），向下移动
  - 该方法主要可以同时利用行、列的有序性，如果从左上角/右下角起始，就没法判断到底该在行还是列方向上移动了



## 链表

> 25-6-4：hot100链表板块

- 160.相交链表：
  - nt方法：哈希表法：把其中一个链表的所有node的地址存到哈希表，然后遍历另一个链表，看是否存在
  - 稍微好一点：长度差法：先计算A和B链表的长度，根据差值来修改短链表的起点，让他们长度一致
  - 最好的方法：双指针法，设A的独有部分长度为a，B的独有部分长度为b，公共部分长度为c。如果2者相交，A遍历到终点之后再遍历B以及B遍历到终点之后再遍历A会在交点处遇到，因为a+c+b=b+c+a

- 206.反转链表：这题是easy高频题，但我老是写不出来，后面还得多刷
  - 迭代法：首先我们每次循环的时候需要3个变量：
    - prev，cur，cur->next
    - 迭代循环里面其实就是：保存下一个节点->反转cur指针->后移prev->后移cur的一个过程
    - 有个细节：其实时cur为head，prev手动指定为nullptr，这样就不用特殊处理头节点了
    - 还有就是返回值不是head，结束条件为cur==nullptr，返回prev
- 234.回文链表：
  - nt方法：用数组保存一下链表内容，然后从2头往中间遍历。空间复杂度为O(n)
  - 最好的方法：先用快慢指针找到链表中点，然后反转右侧的链表，再从2头往中间遍历。
    - 有个细节，就是节点奇偶不同的话，中点的位置不同，如果是偶数还好，如果是奇数的话，中点就是链表的中点（不需要判断该点），所以反转`slow->next`

> 25-6-5：继续hot100链表板块

- 141.环形链表：
  - 环形链表及衍生题一般都用**双指针**法来写，值得注意的是，之前在用双指针法时，一直用慢指针来做循环退出的条件，导致老是写错，现在发现拿快指针更不容易出错（`while(fast && fast->next)`就完事了），此外快慢指针起始时都指向头结点

- 142.环形链表ii：这题也用**双指针**法，有一定的数学在里面：

  - 设链表头到环入口距离为a，环入口到相遇点距离为b，相遇点到环入口距离为c

  - 快指针路程：a + b + n(b + c)，慢指针路程：a + b

  - 由于快指针速度是慢指针2倍：2(a + b) = a + b + n(b + c) => a = (n-1)(b+c) + c
  - 所以这题的解法是先定位相遇点，然后让2个指针以相同的速度走a和c的距离，相遇点就是环的入口，不过要注意，最开始的时候快慢指针的起点得相同，不然就破坏了这个距离关系了

- 21.合并2个有序链表：
  - 这题不要看到要求中的“空间复杂度O（1）”就想到把一个链表中的各元素插到另一个链表中的写法。正确的写法是：弄个新链表，不断把list1和list2中的node**移动**到新的链表中（更新新链表的tail和旧链表的head）

> 25-6-6：继续hot100链表板块

- 2.两数相加：
  - 这题和21.合并2个有序链表比较像：都是创建个新链表，不断往里面添加元素的思路。然后就是list1和list2如何长度不一样的话，要特殊处理
- 19.删除链表的倒数第N个节点：
  - 一般方法：倒数第N个等于整数第size-N个，先遍历一遍链表求出其size，在第二次遍历的时候删掉对应node
  - 最好的方法：使用**快慢指针**的思想，让这2个指针的距离为N，当快指针运动到末尾时，慢指针就位于倒数第N个节点。同时使用**虚拟头节点**来避免删头结点的逻辑
- 24.两两交换链表中的节点
  - 这题必须用虚拟头结点作为`prev`的初值，遍历的时候使用待交换节点`first`和`second`的前驱`prev`来判断是否退出，`first`和`second`每次动态生成

> 25-6-7：继续hot100链表板块

- 138.随机链表的复制：
  - 第一次遍历：创建复制链表,此时只有val和next,同时用hash表记录各node的random字段的指向元素的idx（原始链表的random指向的是原始链表node的地址，所以保存的是idx而不是地址）
  - 第二次遍历：根据hash表找到对应节点，取其地址复制给当前node的random字段
- 148.排序链表
  - nt方法：先遍历一遍链表，把所有node的`val`存到vector，然后对vector排序，再遍历一遍vector，同事创建新链表，最后返回新链表
  - 最优方法：需要归并排序，看不懂...
- 146.LRU缓存
  - 这题需要3个容器和一个变量：
    - 一个cap保存缓存大小
    - 一个hashmap存被缓存的键值对
    - 一个双向链表维护`key`的使用顺序
    - 一个hashmap存`key`与使用顺序双向链表迭代器的映射关系，便于在更新key的值的时候更新其使用顺序

### 总结

1.什么时候用虚拟头节点？

- 核心思想：当链表的头部可能被修改或者删除，或者需要统一的操作逻辑时使用
- 使用场景：
  - 删除头节点：当问题可能涉及删除链表的头节点（如删除倒数第N个节点、删除指定值的节点等），使用虚拟头结点可以避免单独处理头节点被删除的情况
  - 需要构造新链表：当需要从零开始构建一个新链表（如合并两个有序链表、划分链表等），虚拟头结点可以提供一个统一的起始点，避免判空
  - 涉及头节点插入时：当需要在链表头部插入节点（如反转链表、奇偶链表重排等），虚拟头结点可以统一插入逻辑
  - 处理链表分区或重组时：当需要按特定条件划分链表（如将小于x的节点移到前面），虚拟头结点可以分别管理两个子链表的头部



2.什么时候不需要虚拟头结点？

- 仅遍历不修改头节点：如计算链表长度、判断是否有环等
- 头节点不可能被修改：题目明确说明头节点不会被删除或替换（如设计链表类）



3.交换2个节点时，必须保存有待交换2节点的**前驱**的指针，只有待交换的2个节点是不够的，因为要更新`prev->next`为`second`



## STL注意事项

1.`begin`/`end` 和 `front`/`back` 的区别

在 C++ STL 的序列容器（如 `std::list`、`std::vector`、`std::deque`）中，`begin`/`end` 和 `front`/`back` 的指向位置有明确区别，以下是详细说明：

- `begin()`：返回第一个元素的位置的**迭代器**
- `end()`：返回最后一个元素下一个位置的**迭代器**，不可解引用。用途：
  - 判断遍历是否结束
  - 判断是否找到`key`

---

- `rbegin()`：返回最后一个元素的**迭代器**
- `rend()`：指向第一个元素的前一个位置的**迭代器**，不可解引用

- 这俩用于反向便利容器

---

- `c(r)begin()`、`c(r)end()`：迭代器位置和上面一样，但不能修改指向元素的值

---

- `front()`：返回第一个元素的**引用**
- `back()`：返回最后一个元素的**引用**
