# LeetCode_Solutions
算法刷题记录

## 数组

> 25-6-2：hot100数组板块mid题

- 53.最大子数组和：维护一个`current_sum`和`max_sum`，当`current_sum<0`时丢弃之前的子数组重新开始
- 56.合并区间：先对所有区间排序；再判断result的最后一个元素和当前区间有没有交叉：没的话直接添加当前区间到result中，有的话就更新result的最后一个元素
- 189.轮转数组：3次反转数组法：先反转所有、再反转0~k，再反转k+1~n
- 238.除自身之外数组的乘积：结果等于前缀积 * 后缀积
  - 前缀积`left[i]` = `num[0]*num[1]*num[2]...*num[i-1]`(i>=1)
  - 后缀积`right[i]` = `num[i+1]*num[i+2]*num[i+3]...*num[n-1]`(i<=n-2)



## 矩阵

> 25-6-3：hot100矩阵板块

- 73.矩阵置零：先遍历一次矩阵用`set`记录出现0所在的row和col，再遍历一次矩阵，将set中存的位置的所有元素置0

- 54.螺旋矩阵：

  - 设定边界：维护四个边界变量（上、下、左、右）来定义当前需要遍历的矩阵范围
  - 循环处理：按照"右→下→左→上"的顺序遍历每一层
  - 注意事项：遍历每层的时候左、右2侧都是闭区间，并且遍历完一层要立即更新边界，不然会出现最后一个元素遍历不到的情况；“左”和“上”的时候要再判断一下边界关系

- 48.旋转图像：

  - 非原地操作写法：`matrix_new[i][j] = matrix[cols-j-1][i]`
  - 原地操作写法：转置 + 水平翻转（都会用到`swap()`，别忘记了）

  ```
  原始矩阵：  转置后：      水平翻转后：
  1 2 3      1 4 7		7 4 1
  4 5 6  ->  2 5 8  -> 	8 5 2
  7 8 9	   3 6 9		9 6 3
  ```

- 240.搜索二维矩阵 II：
  - nt方法：遍历所有元素查找
  - 稍微好一点：逐行二分法
  - 最好的方法：从右上角或者左下角开始搜索，以从右上角开始为例：这是当前行的最大值，当前列的最小值
    - 如果 `target == matrix[i][j]`，找到目标
    - 如果 `target < matrix[i][j]`，排除当前列（因为当前列的所有元素都更大），向左移动
    - 如果 `target > matrix[i][j]`，排除当前行（因为当前行的所有元素都更小），向下移动
  - 该方法主要可以同时利用行、列的有序性，如果从左上角/右下角起始，就没法判断到底该在行还是列方向上移动了



## 链表

> 25-6-4：hot100链表板块

- 160.相交链表：
  - nt方法：哈希表法：把其中一个链表的所有node的地址存到哈希表，然后遍历另一个链表，看是否存在
  - 稍微好一点：长度差法：先计算A和B链表的长度，根据差值来修改短链表的起点，让他们长度一致
  - 最好的方法：双指针法，设A的独有部分长度为a，B的独有部分长度为b，公共部分长度为c。如果2者相交，A遍历到终点之后再遍历B以及B遍历到终点之后再遍历A会在交点处遇到，因为a+c+b=b+c+a

- 206.反转链表：这题是easy高频题，但我老是写不出来，后面还得多刷
  - 迭代法：首先我们每次循环的时候需要3个变量：
    - prev，cur，cur->next
    - 迭代循环里面其实就是：保存下一个节点->反转cur指针->后移prev->后移cur的一个过程
    - 有个细节：其实时cur为head，prev手动指定为nullptr，这样就不用特殊处理头节点了
    - 还有就是返回值不是head，结束条件为cur==nullptr，返回prev
- 234.回文链表：
  - nt方法：用数组保存一下链表内容，然后从2头往中间遍历。空间复杂度为O(n)
  - 最好的方法：先用快慢指针找到链表中点，然后反转右侧的链表，再从2头往中间遍历。
    - 有个细节，就是节点奇偶不同的话，中点的位置不同，如果是偶数还好，如果是奇数的话，中点就是链表的中点（不需要判断该点），所以反转`slow->next`

> 25-6-5：继续hot100链表板块

- 141.环形链表：
  - 环形链表及衍生题一般都用**双指针**法来写，值得注意的是，之前在用双指针法时，一直用慢指针来做循环退出的条件，导致老是写错，现在发现拿快指针更不容易出错（`while(fast && fast->next)`就完事了），此外快慢指针起始时都指向头结点

- 142.环形链表ii：这题也用**双指针**法，有一定的数学在里面：

  - 设链表头到环入口距离为a，环入口到相遇点距离为b，相遇点到环入口距离为c

  - 快指针路程：a + b + n(b + c)，慢指针路程：a + b

  - 由于快指针速度是慢指针2倍：2(a + b) = a + b + n(b + c) => a = (n-1)(b+c) + c
  - 所以这题的解法是先定位相遇点，然后让2个指针以相同的速度走a和c的距离，相遇点就是环的入口，不过要注意，最开始的时候快慢指针的起点得相同，不然就破坏了这个距离关系了

- 21.合并2个有序链表：
  - 这题不要看到要求中的“空间复杂度O（1）”就想到把一个链表中的各元素插到另一个链表中的写法。正确的写法是：弄个新链表，不断把list1和list2中的node**移动**到新的链表中（更新新链表的tail和旧链表的head）

> 25-6-6：继续hot100链表板块

- 2.两数相加：
  - 这题和21.合并2个有序链表比较像：都是创建个新链表，不断往里面添加元素的思路。然后就是list1和list2如何长度不一样的话，要特殊处理
- 19.删除链表的倒数第N个节点：
  - 一般方法：倒数第N个等于整数第size-N个，先遍历一遍链表求出其size，在第二次遍历的时候删掉对应node
  - 最好的方法：使用**快慢指针**的思想，让这2个指针的距离为N，当快指针运动到末尾时，慢指针就位于倒数第N个节点。同时使用**虚拟头节点**来避免删头结点的逻辑
- 24.两两交换链表中的节点
  - 这题必须用虚拟头结点作为`prev`的初值，遍历的时候使用待交换节点`first`和`second`的前驱`prev`来判断是否退出，`first`和`second`每次动态生成

> 25-6-7：继续hot100链表板块

- 138.随机链表的复制：
  - 第一次遍历：创建复制链表,此时只有val和next,同时用hash表记录各node的random字段的指向元素的idx（原始链表的random指向的是原始链表node的地址，所以保存的是idx而不是地址）
  - 第二次遍历：根据hash表找到对应节点，取其地址复制给当前node的random字段
- 148.排序链表
  - nt方法：先遍历一遍链表，把所有node的`val`存到vector，然后对vector排序，再遍历一遍vector，同事创建新链表，最后返回新链表
  - 最优方法：需要归并排序，看不懂...
- 146.LRU缓存
  - 这题需要3个容器和一个变量：
    - 一个cap保存缓存大小
    - 一个hashmap存被缓存的键值对
    - 一个双向链表维护`key`的使用顺序
    - 一个hashmap存`key`与使用顺序双向链表迭代器的映射关系，便于在更新key的值的时候更新其使用顺序

### 总结

1.什么时候用虚拟头节点？

- 核心思想：当链表的头部可能被修改或者删除，或者需要统一的操作逻辑时使用
- 使用场景：
  - 删除头节点：当问题可能涉及删除链表的头节点（如删除倒数第N个节点、删除指定值的节点等），使用虚拟头结点可以避免单独处理头节点被删除的情况
  - 需要构造新链表：当需要从零开始构建一个新链表（如合并两个有序链表、划分链表等），虚拟头结点可以提供一个统一的起始点，避免判空
  - 涉及头节点插入时：当需要在链表头部插入节点（如反转链表、奇偶链表重排等），虚拟头结点可以统一插入逻辑
  - 处理链表分区或重组时：当需要按特定条件划分链表（如将小于x的节点移到前面），虚拟头结点可以分别管理两个子链表的头部



2.什么时候不需要虚拟头结点？

- 仅遍历不修改头节点：如计算链表长度、判断是否有环等
- 头节点不可能被修改：题目明确说明头节点不会被删除或替换（如设计链表类）



3.交换2个节点时，必须保存有待交换2节点的**前驱**的指针，只有待交换的2个节点是不够的，因为要更新`prev->next`为`second`



## 二叉树

> 25-6-10：hot100二叉树版块

- 94.二叉树的中序遍历
- 104.二叉树的最大深度：

  - BFS：用层序遍历直接秒了
  - DFS：递归法，实现更简单

  ```c
  int maxDepth(TreeNode* root) {
      if (!root) return 0;
      return 1 + std::max(maxDepth(root->left), maxDepth(root->right));
  }
  ```
- 226.翻转二叉树：前序遍历直接秒了

> 25-6-11：继续hot100二叉树版块

- 101.对称二叉树：
  - nt方法：用层序遍历求出每一层的所有node，再判断是否对称
  - 最优方法：使用递归法，同时遍历2个树，再判断左右子树的根节点、左右节点是否对称
- 543.二叉树的直径：
  - 这题是二叉树最大深度的变种题，某节点直径=左子树深度+右子树深度，某节点深度=max(左子树深度, 右子树深度)
  - 所以这题只需要在计算最大深度的同时，更新最大直径就行了
- 102.二叉树的层序遍历：没啥好说的

> 25-6-12：继续hot100二叉树版块

- 108.将有序数组转为二叉搜索树：
  - 这题也要用递归写，递归内的核心逻辑为：
    - 根节点是数组的中间元素（奇数长度）或中间偏右（偶数长度）
    - 左子树由数组左半部分构建，右子树由右半部分构建
    - 终止条件：子数组为空时返回 `nullptr`
  - 有一点要注意：递归的时候每次都要数组，不要创建新数组(会栈溢出)，直接用原数组和，传入边界索引

- 98.验证二叉搜索树：
  - 可以利用中序遍历的性质：中序遍历二叉搜索树的话，一定是升序的
  - 直接用中序遍历把所有元素添加到数组，然后遍历数组检查是不是升序的就行了

- 230.二叉搜索树中第K小元素：
  - 先中序遍历构造一个升序数组，然后直接返回对应的元素就行了



### 总结

- 参考[链接](https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)：看一下基本概念以及二叉树会有==哪些题型==

1.二叉树分类和定义：

- 满二叉树：只有度为0的结点和度为2的结点，并且度为0的结点在同一层上

<img src="F:/个人笔记/assets/image-20250611104127106.png" alt="image-20250611104127106" style="zoom: 33%;" />

- 完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置

<img src="F:/个人笔记/assets/image-20250611104217218.png" alt="image-20250611104217218" style="zoom:67%;" />

- 二叉搜索树：每个节点的数值有序，具体体现在：

  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值

  <img src="F:/个人笔记/assets/image-20250611104502627.png" alt="image-20250611104502627" style="zoom: 50%;" />

- 平衡二叉搜索树：又被称为AVL树，它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树

<img src="F:/个人笔记/assets/image-20250611104615881.png" alt="image-20250611104615881" style="zoom:60%;" />

2.二叉树的遍历方式可以分为深度优先和广度优先2种：

- 深度优先：前/中/后序遍历
  - 使用**递归法**来实现：递归法一定要包含3要素：
    - 确定递归入口函数的返回值和形参
    - 确定终止条件
    - 确定单层逻辑

```cpp
// 递归入口函数(二叉树的递归遍历的入口函数结构都类似)
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    vec.push_back(cur->val);    // 中
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
}
// 前序遍历
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> result;
    traversal(root, result);
    return result;
}
```

- 广度优先：层序遍历
  - 需要使用**队列**来依次存储各层的node

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL) 
        que.push(root);
    vector<vector<int>> result;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
        for (int i = 0; i < size; i++) {
            TreeNode* node = que.front();
            que.pop();
            vec.push_back(node->val);
            if (node->left) 
                que.push(node->left);
            if (node->right) 
                que.push(node->right);
        }
        result.push_back(vec);
    }
    return result;
}
```



## STL

1.`begin`/`end` 和 `front`/`back` 的区别

在 C++ STL 的序列容器（如 `std::list`、`std::vector`、`std::deque`）中，`begin`/`end` 和 `front`/`back` 的指向位置有明确区别，以下是详细说明：

- `begin()`：返回第一个元素的位置的**迭代器**
- `end()`：返回最后一个元素下一个位置的**迭代器**，不可解引用。用途：
  - 判断遍历是否结束
  - 判断是否找到`key`

---

- `rbegin()`：返回最后一个元素的**迭代器**
- `rend()`：指向第一个元素的前一个位置的**迭代器**，不可解引用

- 这俩用于反向便利容器

---

- `c(r)begin()`、`c(r)end()`：迭代器位置和上面一样，但不能修改指向元素的值

---

- `front()`：返回第一个元素的**引用**
- `back()`：返回最后一个元素的**引用**



2.各容器的底层原理

- map、set、multimap，multiset：平衡二叉搜索树
