# LeetCode_Solutions
算法刷题记录

> 25-6-2：hot100数组板块mid题

- 53.最大子数组和：维护一个`current_sum`和`max_sum`，当`current_sum<0`时丢弃之前的子数组重新开始
- 56.合并区间：先对所有区间排序；再判断result的最后一个元素和当前区间有没有交叉：没的话直接添加当前区间到result中，有的话就更新result的最后一个元素
- 189.轮转数组：3次反转数组法：先反转所有、再反转0~k，再反转k+1~n
- 238.除自身之外数组的乘积：结果等于前缀积 * 后缀积
  - 前缀积`left[i]` = `num[0]*num[1]*num[2]...*num[i-1]`(i>=1)
  - 后缀积`right[i]` = `num[i+1]*num[i+2]*num[i+3]...*num[n-1]`(i<=n-2)

> 25-6-3：hot100矩阵板块

- 73.矩阵置零：先遍历一次矩阵用`set`记录出现0所在的row和col，再遍历一次矩阵，将set中存的位置的所有元素置0

- 54.螺旋矩阵：

  - 设定边界：维护四个边界变量（上、下、左、右）来定义当前需要遍历的矩阵范围
  - 循环处理：按照"右→下→左→上"的顺序遍历每一层
  - 注意事项：遍历每层的时候左、右2侧都是闭区间，并且遍历完一层要立即更新边界，不然会出现最后一个元素遍历不到的情况；“左”和“上”的时候要再判断一下边界关系

- 48.旋转图像：

  - 非原地操作写法：`matrix_new[i][j] = matrix[cols-j-1][i]`
  - 原地操作写法：转置 + 水平翻转（都会用到`swap()`，别忘记了）

  ```
  原始矩阵：  转置后：      水平翻转后：
  1 2 3      1 4 7		7 4 1
  4 5 6  ->  2 5 8  -> 	8 5 2
  7 8 9	   3 6 9		9 6 3
  ```

- 240.搜索二维矩阵 II：
  - nt方法：遍历所有元素查找
  - 稍微好一点：逐行二分法
  - 最好的方法：从右上角或者左下角开始搜索，以从右上角开始为例：这是当前行的最大值，当前列的最小值
    - 如果 `target == matrix[i][j]`，找到目标
    - 如果 `target < matrix[i][j]`，排除当前列（因为当前列的所有元素都更大），向左移动
    - 如果 `target > matrix[i][j]`，排除当前行（因为当前行的所有元素都更小），向下移动
  - 该方法主要可以同时利用行、列的有序性，如果从左上角/右下角起始，就没法判断到底该在行还是列方向上移动了

> 25-6-4：hot100链表板块

- 160.相交链表：
  - nt方法：哈希表法：把其中一个链表的所有node的地址存到哈希表，然后遍历另一个链表，看是否存在
  - 稍微好一点：长度差法：先计算A和B链表的长度，根据差值来修改短链表的起点，让他们长度一致
  - 最好的方法：双指针法，设A的独有部分长度为a，B的独有部分长度为b，公共部分长度为c。如果2者相交，A遍历到终点之后再遍历B以及B遍历到终点之后再遍历A会在交点处遇到，因为a+c+b=b+c+a

- 206.反转链表：这题是easy高频题，但我老是写不出来，后面还得多刷
  - 迭代法：首先我们每次循环的时候需要3个变量：
    - prev，cur，cur->next
    - 迭代循环里面其实就是：保存下一个节点->反转cur指针->后移prev->后移cur的一个过程
    - 有个细节：其实时cur为head，prev手动指定为nullptr，这样就不用特殊处理头节点了
    - 还有就是返回值不是head，而是迭代晚的cur；结束条件为cur==nullptr，返回prev
- 234.回文链表：
  - nt方法：用数组保存一下链表内容，然后从2头往中间遍历。空间复杂度为O(n)
  - 最好的方法：先用快慢指针找到链表中点，然后反转右侧的链表，再从2头往中间遍历。
    - 有个细节，就是节点奇偶不同的话，中点的位置不同，如果是偶数还好，如果是奇数的话，中点就是链表的中点（不需要判断该点），所以反转`slow->next`
